require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const bodyParser = require('body-parser');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const multer = require('multer');
const {
  User,
  Template,
  Category,
  PointsPackage,
  Generation,
  AIModel,
  Transaction,
  FinanceConfig,
  HistoryRetentionConfig,
} = require('./models');
const auth = require('./authMiddleware');
const { PointsPackage: PkgModel } = require('./models');
const cloudinary = require('cloudinary').v2;
const fetch = require('node-fetch');
const AIRouter = require('./services/aiRouter');

// Configure Cloudinary (Account 3 - Generated Images)
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME || 'dkeigiajt',
  api_key: process.env.CLOUDINARY_API_KEY || '683965962197886',
  api_secret: process.env.CLOUDINARY_API_SECRET || 'kJzq7XRNTFB33FKKsIK-Pj90T50'
});

const app = express();
app.enable('trust proxy');
const PORT = process.env.PORT || 5000;

// CORS (allow frontend/admin)
const envOrigins = (process.env.ALLOWED_ORIGINS || '')
  .split(',')
  .map(o => o.trim())
  .filter(Boolean);
const allowedOrigins = [
  'http://localhost:3000',
  'http://localhost:3005',
  'https://rupantara-fronted.vercel.app',
  'https://new-admin-pannel-nine.vercel.app',
  ...envOrigins,
];
app.use(cors({
  origin: (origin, cb) => {
    if (!origin) return cb(null, true);
    if (allowedOrigins.includes(origin)) return cb(null, true);
    return cb(null, false);
  },
  credentials: true,
}));
app.use(bodyParser.json({ limit: '10mb' }));
app.use(bodyParser.urlencoded({ extended: true, limit: '10mb' }));
// Normalize versioned routes
app.use((req, res, next) => {
  if (req.url.startsWith('/api/v1/')) {
    req.url = req.url.replace('/api/v1/', '/api/');
  }
  next();
});

// Non-blocking MongoDB connection
const mongoUri = process.env.MONGODB_URI || process.env.MONGO_URI;
const mongoStatus = { connected: false, error: null };
if (mongoUri) {
  mongoose
    .connect(mongoUri, { serverSelectionTimeoutMS: 5000 })
    .then(() => {
      mongoStatus.connected = true;
      console.log('MongoDB connected');
      // Seed minimal data if empty (non-blocking)
      (async () => {
        try {
          const tCount = await Template.countDocuments();
          if (tCount === 0) {
            await Template.insertMany([
              {
                title: 'Vintage Portrait',
                imageUrl: 'https://images.unsplash.com/photo-1544005313-94ddf0286df2?w=500&auto=format&fit=crop&q=60',
                category: 'Portrait',
                prompt: 'vintage portrait soft lighting',
                status: 'active',
                useCount: 120,
                isPremium: false,
                source: 'manual'
              },
              {
                title: 'Fashion Editorial',
                imageUrl: 'https://images.unsplash.com/photo-1524666041070-9f31444b3c28?w=500&auto=format&fit=crop&q=60',
                category: 'Fashion',
                prompt: 'modern fashion editorial',
                status: 'active',
                useCount: 200,
                isPremium: true,
                source: 'manual'
              }
            ]);
            console.log('Seeded Template collection');
          }
          const cCount = await Category.countDocuments();
          if (cCount === 0) {
            await Category.insertMany([
              { name: 'Wedding', subCategories: ['wedding'] },
              { name: 'Fashion', subCategories: ['fashion'] },
              { name: 'Portrait', subCategories: ['portrait'] },
              { name: 'Business', subCategories: ['business'] },
            ]);
            console.log('Seeded Category collection');
          }
          const pCount = await PointsPackage.countDocuments();
          if (pCount === 0) {
            await PointsPackage.insertMany([
              { name: 'Starter', price: 99, points: 100, bonusPoints: 0, isPopular: false, isActive: true, tag: 'basic' },
              { name: 'Pro', price: 299, points: 350, bonusPoints: 50, isPopular: true, isActive: true, tag: 'best' },
              { name: 'Ultra', price: 599, points: 800, bonusPoints: 150, isPopular: false, isActive: true, tag: 'value' },
            ]);
          }
          const mCount = await AIModel.countDocuments();
          if (mCount === 0) {
            await AIModel.create({
              name: 'Pollinations Images',
              provider: 'Pollinations',
              costPerImage: 1,
              isActive: true,
              apiKey: ''
            });
          }
        } catch (e) {
          console.warn('Seeding skipped:', e?.message || e);
        }
      })();
    })
    .catch((err) => {
      mongoStatus.error = err?.message || String(err);
      console.error('MongoDB connection error:', err);
    });
} else {
  console.warn('MONGODB_URI not set; skipping DB connection');
}

app.head('/', (req, res) => {
  res.status(200).end();
});
app.get('/', (req, res) => {
  res.status(200).json({ status: 'ok' });
});

app.all('/health', (req, res) => {
  res.status(200).json({ status: 'ok' });
});

app.get('/api/health', (req, res) => {
  res.status(200).json({ status: 'ok' });
});

// Database health
app.get('/api/db/health', (req, res) => {
  const connected = !!(mongoose.connection && mongoose.connection.readyState === 1);
  res.status(200).json({ status: 'ok', connected, info: mongoStatus });
});

app.get('/favicon.ico', (req, res) => {
  res.status(204).end();
});

// Minimal placeholder API routes to avoid 404s during stabilization
app.get('/api', (req, res) => {
  res.status(200).json({ status: 'ok', message: 'Minimal API' });
});
app.get(['/api/templates', '/api/v1/templates'], async (req, res) => {
  try {
    const useDb = mongoose.connection && mongoose.connection.readyState === 1;
    if (useDb) {
      const list = await Template.find({ status: 'active' }).sort({ useCount: -1 }).limit(100);
      return res.json(list.map(t => ({
        id: t._id,
        title: t.title,
        description: t.prompt,
        demoImage: t.imageUrl,
        additionalImages: [],
        category: t.category,
        subCategory: t.subCategory,
        tags: [],
        creatorId: t.creatorId || null,
        creatorName: 'Creator',
        creatorVerified: true,
        hiddenPrompt: t.prompt,
        visiblePrompt: t.prompt,
        negativePrompt: '',
        isFree: !t.isPremium,
        pointsCost: t.isPremium ? 10 : 0,
        usageCount: t.useCount || 0,
        likeCount: t.likeCount || 0,
        saveCount: 0,
        rating: 4.5,
        ratingCount: 8,
        ageGroup: 'adult',
        state: 'IN',
        status: t.status
      })));
    }
    return res.json([]);
  } catch (e) {
    res.status(500).json({ error: 'Failed to fetch templates' });
  }
});
app.get(['/api/templates/:id', '/api/v1/templates/:id'], async (req, res) => {
  try {
    const t = await Template.findById(req.params.id);
    if (!t) return res.status(404).json({ error: 'Not found' });
    return res.json({
      id: t._id,
      title: t.title,
      description: t.prompt,
      demoImage: t.imageUrl,
      additionalImages: [],
      category: t.category,
      subCategory: t.subCategory,
      tags: [],
      creatorId: t.creatorId || null,
      creatorName: 'Creator',
      creatorVerified: true,
      hiddenPrompt: t.prompt,
      visiblePrompt: t.prompt,
      negativePrompt: '',
      isFree: !t.isPremium,
      pointsCost: t.isPremium ? 10 : 0,
      usageCount: t.useCount || 0,
      likeCount: t.likeCount || 0,
      saveCount: 0,
      rating: 4.5,
      ratingCount: 8,
      ageGroup: 'adult',
      state: 'IN',
      status: t.status
    });
  } catch (e) {
    res.status(500).json({ error: 'Failed to fetch template' });
  }
});
app.get(['/api/user', '/api/v1/user'], (req, res) => {
  res.status(200).json({});
});
app.get(['/template', '/api/template', '/api/v1/template'], (req, res) => {
  res.status(200).json({ status: 'ok' });
});
app.get(['/api/admin/templates/categories', '/api/v1/admin/templates/categories'], async (req, res) => {
  try {
    const useDb = mongoose.connection && mongoose.connection.readyState === 1;
    if (useDb) {
      const cats = await Category.find();
      return res.json(cats.map(c => ({ id: c._id, name: c.name, subCategories: c.subCategories || [] })));
    }
    return res.json([]);
  } catch (e) {
    res.status(500).json({ error: 'Failed to fetch categories' });
  }
});

app.post(['/api/payment/create-order', '/api/v1/payment/create-order'], auth, async (req, res) => {
  try {
    const { packageId, gateway = 'razorpay' } = req.body || {};
    const user = await User.findById(req.user.id);
    const pkg = await PkgModel.findById(packageId);
    if (!pkg || !pkg.isActive) return res.status(400).json({ error: 'Invalid package' });
    const orderId = `order_${Date.now()}`;
    const amount = pkg.price;
    res.json({ order_id: orderId, amount, currency: 'INR', gateway, packageId });
  } catch (e) {
    res.status(500).json({ error: 'Failed to create order' });
  }
});
app.post(['/api/payment/verify-razorpay', '/api/v1/payment/verify-razorpay'], auth, async (req, res) => {
  try {
    const { razorpay_order_id, razorpay_payment_id, razorpay_signature, packageId } = req.body || {};
    const user = await User.findById(req.user.id);
    const pkg = await PkgModel.findById(packageId);
    if (!pkg || !pkg.isActive) return res.status(400).json({ error: 'Invalid package' });
    user.points = (user.points || 0) + (pkg.points || 0) + (pkg.bonusPoints || 0);
    await user.save();
    await Transaction.create({
      userId: user._id,
      amount: pkg.price,
      type: 'credit',
      description: `Points purchase: ${pkg.name}`,
      gateway: 'Razorpay',
      status: 'success',
      date: new Date()
    });
    res.json({ success: true, points: user.points });
  } catch (e) {
    res.status(500).json({ error: 'Verification failed' });
  }
});

app.post(['/api/auth/syncUser', '/api/v1/auth/syncUser'], async (req, res) => {
  try {
    const { firebaseToken, fullName, phone } = req.body || {};
    const name = (fullName || 'User').trim();
    const email = `firebase_${Date.now()}@example.com`;
    let user = await User.findOne({ email });
    if (!user) {
      user = await User.create({ name, email, role: 'user', points: 100, status: 'active' });
    }
    const payload = { user: { id: user.id, role: user.role } };
    const token = jwt.sign(payload, process.env.JWT_SECRET || 'secret', { expiresIn: '7d' });
    res.json({ token, user: { id: user.id, name: user.name, email: user.email, points: user.points, role: user.role } });
  } catch (e) {
    res.status(500).send('Server Error');
  }
});

app.get(['/api/wallet/balance', '/api/v1/wallet/balance'], auth, async (req, res) => {
  const user = await User.findById(req.user.id);
  res.json({ points: user.points || 0 });
});
app.get(['/api/wallet/transactions', '/api/v1/wallet/transactions'], auth, async (req, res) => {
  const page = parseInt(req.query.page || '1', 10);
  const limit = parseInt(req.query.limit || '20', 10);
  const type = req.query.type;
  const filter = { userId: req.user.id };
  if (type === 'credit' || type === 'debit') filter.type = type;
  const list = await Transaction.find(filter).sort({ date: -1 }).skip((page - 1) * limit).limit(limit);
  res.json({ transactions: list });
});
app.post(['/api/wallet/add-points', '/api/v1/wallet/add-points'], auth, async (req, res) => {
  const { amount = 0, description = 'Manual credit' } = req.body || {};
  const user = await User.findById(req.user.id);
  user.points = (user.points || 0) + Number(amount);
  await user.save();
  await Transaction.create({
    userId: user._id,
    amount: Number(amount),
    type: 'credit',
    description,
    gateway: 'System',
    status: 'success',
    date: new Date()
  });
  res.json({ success: true, points: user.points });
});

app.get(['/api/creator/application', '/api/v1/creator/application'], auth, async (req, res) => {
  const appDoc = await mongoose.model('CreatorApplication').findOne({ userId: req.user.id }).sort({ appliedDate: -1 });
  if (!appDoc) return res.status(404).json({ status: 'none' });
  res.json({ id: String(appDoc._id), userId: String(appDoc.userId), name: appDoc.name, socialLinks: appDoc.socialLinks || [], status: appDoc.status, appliedDate: appDoc.appliedDate });
});
app.post(['/api/creator/apply', '/api/v1/creator/apply'], auth, async (req, res) => {
  const { name, socialLinks = [] } = req.body || {};
  const finalName = (name || '').toString().replace(/^@/, '').trim();
  if (!finalName) return res.status(400).json({ error: 'Name is required' });
  const appDoc = await mongoose.model('CreatorApplication').create({ userId: req.user.id, name: finalName, socialLinks });
  res.json({ id: String(appDoc._id), userId: String(appDoc.userId), name: appDoc.name, socialLinks: appDoc.socialLinks || [], status: appDoc.status, appliedDate: appDoc.appliedDate });
});
app.get(['/api/creator/earnings', '/api/v1/creator/earnings'], auth, async (req, res) => {
  const credits = await Transaction.aggregate([{ $match: { userId: new mongoose.Types.ObjectId(req.user.id), type: 'credit' } }, { $group: { _id: null, total: { $sum: '$amount' } } }]);
  const debits = await Transaction.aggregate([{ $match: { userId: new mongoose.Types.ObjectId(req.user.id), type: 'debit' } }, { $group: { _id: null, total: { $sum: '$amount' } } }]);
  const earned = (credits[0]?.total || 0) - (debits[0]?.total || 0);
  res.json({ totalEarnings: earned, credits: credits[0]?.total || 0, debits: debits[0]?.total || 0 });
});
app.post(['/api/creator/withdraw', '/api/v1/creator/withdraw'], auth, async (req, res) => {
  const { amount = 0, method = 'upi', upiId, bankDetails } = req.body || {};
  await Transaction.create({
    userId: req.user.id,
    amount: Number(amount),
    type: 'debit',
    description: `Withdrawal (${method})`,
    gateway: 'System',
    status: 'success',
    date: new Date()
  });
  res.json({ success: true });
});
app.get(['/api/creator/withdrawals', '/api/v1/creator/withdrawals'], auth, async (req, res) => {
  const list = await Transaction.find({ userId: req.user.id, type: 'debit', description: /Withdrawal/ }).sort({ date: -1 });
  res.json({ withdrawals: list });
});

app.post(['/api/tools/remove-bg', '/api/v1/tools/remove-bg'], auth, async (req, res) => {
  const { imageUrl } = req.body || {};
  res.json({ processedImage: imageUrl });
});
app.post(['/api/tools/upscale', '/api/v1/tools/upscale'], auth, async (req, res) => {
  const { imageUrl } = req.body || {};
  res.json({ processedImage: imageUrl });
});
app.post(['/api/tools/face-enhance', '/api/v1/tools/face-enhance'], auth, async (req, res) => {
  const { imageUrl } = req.body || {};
  res.json({ processedImage: imageUrl });
});
app.post(['/api/tools/compress', '/api/v1/tools/compress'], auth, async (req, res) => {
  const { imageUrl } = req.body || {};
  res.json({ processedImage: imageUrl });
});
const upload = multer({ storage: multer.memoryStorage() });
app.post(['/api/admin/upload/template-demo', '/api/v1/admin/upload/template-demo'], auth, upload.single('image'), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: 'No file' });
    const b64 = req.file.buffer.toString('base64');
    return res.json({ url: `data:${req.file.mimetype || 'image/png'};base64,${b64}` });
  } catch (e) {
    res.status(500).json({ error: 'Upload failed' });
  }
});
app.get(['/api/admin/templates', '/api/v1/admin/templates'], auth, async (req, res) => {
  try {
    const list = await Template.find().sort({ useCount: -1 });
    res.json(list.map(t => ({ id: t._id, title: t.title, imageUrl: t.imageUrl, category: t.category, subCategory: t.subCategory, prompt: t.prompt, status: t.status, isPremium: t.isPremium, source: t.source })));
  } catch (e) {
    res.status(500).json({ error: 'Failed to fetch templates' });
  }
});
app.post(['/api/admin/templates', '/api/v1/admin/templates'], auth, async (req, res) => {
  try {
    const { title, imageUrl, category, subCategory, prompt, status = 'active', isPremium = false, source = 'manual' } = req.body || {};
    if (!title || !imageUrl) return res.status(400).json({ error: 'title and imageUrl required' });
    const doc = await Template.create({ title, imageUrl, category, subCategory, prompt, status, isPremium, source, creatorId: req.user?.id || null });
    res.json({ id: doc._id, title: doc.title, imageUrl: doc.imageUrl, category: doc.category, subCategory: doc.subCategory, prompt: doc.prompt, status: doc.status, isPremium: doc.isPremium, source: doc.source });
  } catch (e) {
    res.status(500).json({ error: 'Failed to create template' });
  }
});
app.put(['/api/admin/templates/:id', '/api/v1/admin/templates/:id'], auth, async (req, res) => {
  try {
    const updated = await Template.findByIdAndUpdate(req.params.id, req.body, { new: true });
    if (!updated) return res.status(404).json({ error: 'Not found' });
    res.json({ id: updated._id, title: updated.title, imageUrl: updated.imageUrl, category: updated.category, subCategory: updated.subCategory, prompt: updated.prompt, status: updated.status, isPremium: updated.isPremium, source: updated.source });
  } catch (e) {
    res.status(500).json({ error: 'Failed to update template' });
  }
});
app.delete(['/api/admin/templates/:id', '/api/v1/admin/templates/:id'], auth, async (req, res) => {
  try {
    await Template.deleteOne({ _id: req.params.id });
    res.json({ success: true });
  } catch (e) {
    res.status(500).json({ error: 'Failed to delete template' });
  }
});

// Admin AI Config
app.get(['/api/admin/config/ai', '/api/v1/admin/config/ai'], async (req, res) => {
  try {
    const models = await AIModel.find();
    const finance = await FinanceConfig.findOne() || { costPerCredit: 0.2, currency: 'INR', taxRate: 18 };
    res.json({ models, finance });
  } catch (e) {
    res.status(500).json({ error: 'Failed to fetch AI config' });
  }
});
app.post(['/api/admin/config/ai', '/api/v1/admin/config/ai'], async (req, res) => {
  try {
    const model = await AIModel.create(req.body);
    res.json({ ...model._doc, id: model._id });
  } catch (e) {
    res.status(500).json({ error: 'Failed to create model' });
  }
});
app.patch(['/api/admin/config/ai/:id', '/api/v1/admin/config/ai/:id'], async (req, res) => {
  try {
    const updated = await AIModel.findByIdAndUpdate(req.params.id, req.body, { new: true });
    if (!updated) return res.status(404).json({ error: 'Not found' });
    res.json({ ...updated._doc, id: updated._id });
  } catch (e) {
    res.status(500).json({ error: 'Failed to update model' });
  }
});
app.delete(['/api/admin/config/ai/:id', '/api/v1/admin/config/ai/:id'], async (req, res) => {
  try {
    await AIModel.findByIdAndDelete(req.params.id);
    res.json({ success: true });
  } catch (e) {
    res.status(500).json({ error: 'Failed to delete model' });
  }
});
app.put(['/api/admin/config/ai/:id/activate', '/api/v1/admin/config/ai/:id/activate'], async (req, res) => {
  try {
    await AIModel.updateMany({}, { isActive: false });
    await AIModel.findByIdAndUpdate(req.params.id, { isActive: true });
    res.json({ success: true });
  } catch (e) {
    res.status(500).json({ error: 'Failed to activate model' });
  }
});
app.put(['/api/admin/config/ai/:id/cost', '/api/v1/admin/config/ai/:id/cost'], async (req, res) => {
  try {
    await AIModel.findByIdAndUpdate(req.params.id, { costPerImage: req.body.cost });
    res.json({ success: true });
  } catch (e) {
    res.status(500).json({ error: 'Failed to update cost' });
  }
});
app.put(['/api/admin/config/ai/:id/apikey', '/api/v1/admin/config/ai/:id/apikey'], async (req, res) => {
  try {
    await AIModel.findByIdAndUpdate(req.params.id, { apiKey: req.body.apiKey });
    res.json({ success: true });
  } catch (e) {
    res.status(500).json({ error: 'Failed to update API key' });
  }
});
app.put(['/api/admin/config/ai/:id/details', '/api/v1/admin/config/ai/:id/details'], async (req, res) => {
  try {
    await AIModel.findByIdAndUpdate(req.params.id, req.body);
    res.json({ success: true });
  } catch (e) {
    res.status(500).json({ error: 'Failed to update model details' });
  }
});
app.post(['/api/admin/config/ai/:id/test', '/api/v1/admin/config/ai/:id/test'], async (req, res) => {
  res.json({ success: true });
});
app.delete(['/api/admin/config/ai/cache', '/api/v1/admin/config/ai/cache'], async (req, res) => {
  res.json({ success: true });
});

app.post(['/api/auth/register', '/api/v1/auth/register'], async (req, res) => {
  try {
    const { name, fullName, email, password } = req.body;
    const finalName = (name || fullName || (email ? String(email).split('@')[0] : 'User')).trim();
    let user = await User.findOne({ email });
    if (user) return res.status(400).json({ msg: 'User already exists' });
    const hashedPassword = await bcrypt.hash(password, 10);
    user = new User({ name: finalName, email, password: hashedPassword, role: 'user', points: 50 });
    await user.save();
    const payload = { user: { id: user.id, role: user.role } };
    const token = jwt.sign(payload, process.env.JWT_SECRET || 'secret', { expiresIn: '7d' });
    res.json({ token, user: { id: user.id, name: user.name, email: user.email, points: user.points, role: user.role } });
  } catch (err) {
    res.status(500).send('Server Error');
  }
});
app.post(['/api/auth/login', '/api/v1/auth/login'], async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email }).select('+password');
    if (!user || !(await bcrypt.compare(String(password), String(user.password)))) {
      return res.status(400).json({ msg: 'Invalid Credentials' });
    }
    const payload = { user: { id: user.id, role: user.role } };
    const token = jwt.sign(payload, process.env.JWT_SECRET || 'secret', { expiresIn: '7d' });
    res.json({ token, user: { id: user.id, name: user.name, email: user.email, points: user.points, role: user.role } });
  } catch (err) {
    res.status(500).send('Server Error');
  }
});
app.post(['/api/auth/social-login', '/api/v1/auth/social-login'], async (req, res) => {
  try {
    const { provider = 'google', email, name } = req.body;
    const finalEmail = email && String(email).trim() ? email : `${provider}_user_${Date.now()}@example.com`;
    let user = await User.findOne({ email: finalEmail });
    if (!user) {
      user = await User.create({ name: name || provider.charAt(0).toUpperCase() + provider.slice(1) + ' User', email: finalEmail, role: 'user', points: 100, status: 'active' });
    }
    const payload = { user: { id: user.id, role: user.role } };
    const token = jwt.sign(payload, process.env.JWT_SECRET || 'secret', { expiresIn: '7d' });
    res.json({ token, user: { id: user.id, name: user.name, email: user.email, points: user.points, role: user.role } });
  } catch (err) {
    res.status(500).send('Server Error');
  }
});
app.get(['/api/auth/me', '/api/v1/auth/me', '/api/user/me', '/api/v1/user/me'], auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    res.json(user);
  } catch (err) {
    res.status(500).send('Server Error');
  }
});

app.get(['/api/packages', '/api/v1/packages'], async (req, res) => {
  try {
    const pkgs = await PointsPackage.find({ isActive: true });
    res.json(pkgs);
  } catch (err) {
    res.status(500).send('Server Error');
  }
});

// ==================== AI MODEL MANAGEMENT ENDPOINTS ====================

// Get all AI models (for admin panel)
app.get(['/api/admin/ai-models', '/api/v1/admin/ai-models'], async (req, res) => {
  try {
    const models = await AIModel.find({}).select('+config.apiKey');
    res.json(models);
  } catch (err) {
    console.error('Error fetching AI models:', err);
    res.status(500).json({ error: 'Failed to fetch AI models' });
  }
});

// Create new AI model
app.post(['/api/admin/ai-models', '/api/v1/admin/ai-models'], async (req, res) => {
  try {
    const { name, provider, costPerImage, key, config } = req.body;

    // Basic validation
    if (!name || !provider) {
      return res.status(400).json({ error: 'Name and Provider are required' });
    }

    // Generate key from name if not provided, ensuring lowercase and no spaces
    const modelKey = key || name.toLowerCase().replace(/\s+/g, '-');

    // Check if key already exists
    const existing = await AIModel.findOne({ key: modelKey });
    if (existing) {
      return res.status(400).json({ error: 'AI Model with this key/name already exists' });
    }

    const newModel = await AIModel.create({
      key: modelKey,
      name,
      provider,
      costPerImage: costPerImage || 1.0,
      active: false, // Default to inactive for safety
      config: config || {},
      stats: {
        totalGenerations: 0,
        successRate: 100,
        averageTime: 0
      }
    });

    res.status(201).json({
      success: true,
      data: newModel,
      message: 'AI Model created successfully'
    });
  } catch (err) {
    console.error('Error creating AI model:', err);
    res.status(500).json({ error: 'Failed to create AI model', details: err.message });
  }
});

// Get single AI model
app.get(['/api/admin/ai-models/:key', '/api/v1/admin/ai-models/:key'], async (req, res) => {
  try {
    const model = await AIModel.findOne({ key: req.params.key }).select('+config.apiKey');
    if (!model) {
      return res.status(404).json({ error: 'AI model not found' });
    }
    res.json(model);
  } catch (err) {
    console.error('Error fetching AI model:', err);
    res.status(500).json({ error: 'Failed to fetch AI model' });
  }
});

// Activate an AI model
app.post(['/api/admin/ai-models/:key/activate', '/api/v1/admin/ai-models/:key/activate'], async (req, res) => {
  try {
    const model = await AIModel.findOne({ key: req.params.key });
    if (!model) {
      return res.status(404).json({ error: 'AI model not found' });
    }

    // Set this model as active (pre-save hook will deactivate others)
    model.active = true;
    await model.save();

    res.json({
      success: true,
      message: `${model.name} is now active`,
      activeAI: model.key
    });
  } catch (err) {
    console.error('Error activating AI model:', err);
    res.status(500).json({ error: 'Failed to activate AI model' });
  }
});

// Update AI model configuration
app.put(['/api/admin/ai-models/:key', '/api/v1/admin/ai-models/:key'], async (req, res) => {
  try {
    const { name, costPerImage, config } = req.body;
    const model = await AIModel.findOne({ key: req.params.key });

    if (!model) {
      return res.status(404).json({ error: 'AI model not found' });
    }

    if (name) model.name = name;
    if (costPerImage !== undefined) model.costPerImage = costPerImage;
    if (config) {
      if (config.apiKey) model.config.apiKey = config.apiKey;
      if (config.model) model.config.model = config.model;
      if (config.defaultParams) model.config.defaultParams = config.defaultParams;
    }

    await model.save();

    res.json({
      success: true,
      message: 'AI model updated successfully',
      model
    });
  } catch (err) {
    console.error('Error updating AI model:', err);
    res.status(500).json({ error: 'Failed to update AI model' });
  }
});

// Delete AI model
app.delete(['/api/admin/ai-models/:key', '/api/v1/admin/ai-models/:key'], async (req, res) => {
  try {
    console.log('Delete AI model request:', req.params.key);

    // Try to find by key first, then by id
    let model = await AIModel.findOne({ key: req.params.key });

    if (!model) {
      // Try finding by _id
      model = await AIModel.findById(req.params.key);
    }

    if (!model) {
      console.log('AI model not found:', req.params.key);
      return res.status(404).json({ error: 'AI model not found' });
    }

    console.log('Found model:', model.name, 'Active:', model.active);

    // Safety check: Cannot delete active AI model
    if (model.active) {
      return res.status(400).json({
        error: 'Cannot delete active AI model',
        message: 'Please activate another AI model before deleting this one'
      });
    }

    // Check if this is the last AI model
    const totalModels = await AIModel.countDocuments();
    if (totalModels <= 1) {
      return res.status(400).json({
        error: 'Cannot delete the last AI model',
        message: 'At least one AI model must exist in the system'
      });
    }

    // Delete by _id to be safe
    await AIModel.deleteOne({ _id: model._id });

    console.log('AI model deleted successfully:', model.name);

    res.json({
      success: true,
      message: `${model.name} deleted successfully`
    });
  } catch (err) {
    console.error('Error deleting AI model:', err);
    res.status(500).json({ error: 'Failed to delete AI model', details: err.message });
  }
});

app.post(['/api/generation/generate', '/api/v1/generation/generate'], auth, async (req, res) => {
  try {
    const { templateId, userPrompt, prompt, negativePrompt, uploadedImages = [], quality = 'HD', aspectRatio = '1:1', faceImageUrl } = req.body;
    const user = await User.findById(req.user.id);

    // Get cost from active AI (router will fetch it)
    const router = new AIRouter(AIModel);
    const activeAI = await router.getActiveAI();
    const cost = activeAI?.costPerImage ?? 20;

    if (user.points < cost) return res.status(400).json({ error: 'Insufficient points' });

    // Lock user points first (deduct immediately)
    user.points -= cost;
    await user.save();

    // Get template if provided
    const template = templateId ? await Template.findById(templateId) : null;

    // Build final prompt: template hidden prompt + user prompt
    let finalPrompt = '';
    if (template && template.prompt) {
      finalPrompt = template.prompt; // Template's hidden prompt
      if (userPrompt || prompt) {
        finalPrompt += `, ${userPrompt || prompt}`; // Merge with user's input
      }
    } else {
      finalPrompt = userPrompt || prompt || '';
    }

    // Prepare reference images array (Cloudinary URLs)
    const referenceImages = [];
    if (uploadedImages && Array.isArray(uploadedImages)) {
      for (const img of uploadedImages) {
        if (typeof img === 'string' && (img.startsWith('http') || img.startsWith('data:'))) {
          referenceImages.push(img);
        }
      }
    }

    // Generate image using AI Router (multi-AI system)
    let generatedImageUrl;
    let aiUsed = 'Unknown';
    let aiKey = 'unknown';

    try {
      // Initialize AI Router
      const router = new AIRouter(AIModel);

      // Generate image - router will select active AI automatically
      const result = await router.generateImage({
        prompt: finalPrompt,
        referenceImages: referenceImages,
        aspectRatio: aspectRatio || '1:1',
        quality: quality || 'HD',
        negativePrompt: negativePrompt || ''
      });

      generatedImageUrl = result.imageUrl;
      aiUsed = result.aiUsed;
      aiKey = result.aiKey;

    } catch (error) {
      console.error('AI Generation Error:', error);

      // REFUND POINTS - generation failed
      user.points += cost;
      await user.save();

      // Log failed transaction
      await Transaction.create({
        userId: user._id,
        amount: cost,
        type: 'credit',
        description: `Refund: Image generation failed - ${error.message}`,
        gateway: 'System',
        status: 'success',
        date: new Date()
      });

      // Return user-friendly error
      return res.status(500).json({
        error: 'Failed to generate image. Your points have been refunded.',
        details: error.message,
        refunded: true
      });
    }

    const safeUploadedImages = (Array.isArray(uploadedImages) ? uploadedImages : [])
      .slice(0, 5)
      .map((img) => {
        if (typeof img === 'string' && img.startsWith('data:')) {
          return img.slice(0, 200);
        }
        return img;
      });

    const gen = await Generation.create({
      userId: user._id,
      templateId: template?._id,
      templateName: template?.title,
      prompt: finalPrompt,
      negativePrompt: negativePrompt || '',
      uploadedImages: safeUploadedImages,
      generatedImage: generatedImageUrl,
      quality,
      aspectRatio,
      pointsSpent: cost,
      status: 'completed',
      modelUsed: aiUsed,
      modelProvider: aiKey,
      seed: Date.now()
    });

    // Update user stats (points already deducted above)
    user.usesCount = (user.usesCount || 0) + 1;
    await user.save();

    // Log transaction
    await Transaction.create({
      userId: user._id,
      amount: cost,
      type: 'debit',
      description: `Image generation via ${aiUsed} (${quality})`,
      gateway: 'System',
      status: 'success',
      date: new Date()
    });

    if (template) {
      template.useCount = (template.useCount || 0) + 1;
      await template.save();
    }

    const response = {
      id: String(gen._id),
      generatedImage: gen.generatedImage,
      visiblePrompt: template ? (template.title || 'AI Generated Image') : 'AI Generated Image',
      quality: gen.quality,
      aspectRatio: gen.aspectRatio,
      pointsSpent: gen.pointsSpent,
      status: gen.status,
      createdAt: gen.createdAt.toISOString(),
      isFavorite: gen.isFavorite,
      downloadCount: gen.downloadCount,
      shareCount: gen.shareCount,
      modelUsed: aiUsed,
      modelProvider: aiKey,
      seed: gen.seed
    };
    res.json(response);
  } catch (err) {
    res.status(500).json({ error: 'Server Error' });
  }
});
app.post(['/api/generate', '/api/v1/generate'], auth, async (req, res) => {
  req.url = '/api/generation/generate';
  app._router.handle(req, res);
});
app.get(['/api/generation/history', '/api/v1/generation/history'], auth, async (req, res) => {
  try {
    const page = parseInt(req.query.page || '1', 10);
    const limit = parseInt(req.query.limit || '20', 10);
    const skip = (page - 1) * limit;
    
    // Use compound index (userId, createdAt) for efficient querying
    // allowDiskUse as fallback for very large datasets
    const list = await Generation.find({ userId: req.user.id })
      .sort({ createdAt: -1 })
      .allowDiskUse(true)
      .skip(skip)
      .limit(limit)
      .lean(); // Use lean() for better performance with large datasets
    
    res.json({
      generations: list.map(g => ({
        id: String(g._id),
        generatedImage: g.generatedImage,
        visiblePrompt: g.templateName || 'AI Generated Image',
        quality: g.quality,
        aspectRatio: g.aspectRatio,
        pointsSpent: g.pointsSpent,
        createdAt: g.createdAt.toISOString(),
        isFavorite: g.isFavorite,
        downloadCount: g.downloadCount,
        shareCount: g.shareCount
      }))
    });
  } catch (error) {
    console.error('âŒ Error fetching generation history:', error);
    console.error('Error details:', {
      name: error.name,
      message: error.message,
      code: error.code,
      codeName: error.codeName
    });
    res.status(500).json({ 
      error: 'Failed to fetch generation history',
      message: error.message 
    });
  }
});
app.get(['/api/generation/:id', '/api/v1/generation/:id'], auth, async (req, res) => {
  const g = await Generation.findOne({ _id: req.params.id, userId: req.user.id });
  if (!g) return res.status(404).json({ error: 'Not found' });
  res.json({
    id: String(g._id),
    generatedImage: g.generatedImage,
    visiblePrompt: g.templateName || 'AI Generated Image',
    quality: g.quality,
    aspectRatio: g.aspectRatio,
    createdAt: g.createdAt.toISOString(),
    isFavorite: g.isFavorite,
    downloadCount: g.downloadCount,
    shareCount: g.shareCount
  });
});
app.patch(['/api/generation/:id/favorite', '/api/v1/generation/:id/favorite'], auth, async (req, res) => {
  const g = await Generation.findOneAndUpdate({ _id: req.params.id, userId: req.user.id }, { $bit: { isFavorite: { xor: 1 } } }, { new: true });
  if (!g) return res.status(404).json({ error: 'Not found' });
  res.json({ success: true, isFavorite: g.isFavorite });
});
app.delete(['/api/generation/:id', '/api/v1/generation/:id'], auth, async (req, res) => {
  await Generation.deleteOne({ _id: req.params.id, userId: req.user.id });
  res.json({ success: true });
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on port ${PORT}`);
});
